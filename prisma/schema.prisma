// ======================================================
// ROOT PRISMA SETUP (Prisma 7 compatible)
// ======================================================

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id         String      @id @default(cuid())
  email      String      @unique
  phoneNo    String
  name       String
  password   String
  age        Int
  gender     Gender      @default(MALE)
  role       Role        @default(PATIENT)
  address    String
  city       String
  state      String
  pinCode    Int
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  accessLogs AccessLog[]
  admin      Admin?
  auditLogs  AuditLog[]
  doctor     Doctor?
  patient    Patient?
}

model Admin {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Doctor {
  id               String                  @id @default(cuid())
  userId           String                  @unique
  specialty        Specialty
  experience       Int                     @default(0)
  qualifications   Qualification[]
  fees             Int                     @default(0)
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  appointments     Appointment[]
  user             User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  patientRelations DoctorPatientRelation[]
  leaves           Leave[]
  schedule         Schedule?
  slots            Slot[]
}

model Patient {
  id                 String                  @id @default(cuid())
  userId             String                  @unique
  medicalHistory     String                  @default("")
  allergies          String                  @default("")
  currentMedications String                  @default("")
  createdAt          DateTime                @default(now())
  updatedAt          DateTime                @updatedAt
  appointments       Appointment[]
  doctorRelations    DoctorPatientRelation[]
  user               User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Leave {
  id        String   @id @default(cuid())
  doctorId  String
  reason    String
  startDate DateTime
  endDate   DateTime
  applyAt   DateTime @default(now())
  doctor    Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  @@unique([doctorId, startDate, endDate])
  @@index([doctorId])
  @@index([startDate, endDate])
}

/// *
///  * Weekly schedule JSON is the canonical repeating schedule (e.g. working hours per weekday).
///  * Use this for generating Slots for upcoming days.
///  * Example format:
///  * {
///  * "monday": [{ "start": "09:00", "end": "13:00" }, { "start": "15:00", "end": "18:00" }],
///  * ...
///  * }
model Schedule {
  id             String   @id @default(cuid())
  doctorId       String   @unique
  weeklySchedule Json
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  doctor         Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)
}

/// *
///  * Slot = a discrete time window for a doctor (bookable)
///  * - startTime/endTime are full timestamps in UTC
///  * - status: AVAILABLE / HELD / BOOKED / etc
///  * Slot is the defining side of the one-to-one relation to Appointment:
///  * - appointmentId is the scalar FK (unique)
///  * - appointment relation uses @relation(fields: [appointmentId], references: [id], onDelete: SetNull)
///  * Appointment will not declare scalar fields for this relation (Prisma infers inverse).
model Slot {
  id              String       @id @default(cuid())
  doctorId        String
  date            DateTime     @db.Date
  startTime       DateTime
  endTime         DateTime
  status          SlotStatus   @default(AVAILABLE)
  heldByPatientId String?
  heldAt          DateTime?
  appointmentId   String?      @unique
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  appointment     Appointment? @relation(fields: [appointmentId], references: [id])
  doctor          Doctor       @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  @@unique([doctorId, date, startTime])
  @@index([doctorId, date, status])
  @@index([startTime, status])
  @@index([heldByPatientId])
}

/// *
///  * Appointment = finalized booking of a patient with a doctor.
///  * NOTE: removed the scalar field `slotId` (it was duplicating the relation).
///  * The inverse relation `slot` is declared without @relation attributes; Prisma will infer it.
model Appointment {
  id                  String            @id @default(cuid())
  doctorId            String
  patientId           String
  status              AppointmentStatus @default(PENDING)
  notes               String?
  cancelReason        String?
  cancelledAt         DateTime?
  appointmentDateTime DateTime
  durationMinutes     Int               @default(30)
  bookedAt            DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  doctor              Doctor            @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient             Patient           @relation(fields: [patientId], references: [id], onDelete: Cascade)
  slot                Slot?

  @@unique([doctorId, appointmentDateTime])
  @@index([doctorId, patientId])
  @@index([status])
  @@index([appointmentDateTime])
}

model DoctorPatientRelation {
  id        String   @id @default(cuid())
  doctorId  String
  patientId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  doctor    Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient   Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)

  @@unique([doctorId, patientId])
  @@index([patientId])
  @@index([doctorId])
}

model AccessLog {
  id        String   @id @default(cuid())
  userId    String?
  targetId  String?
  action    String
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  metadata  Json?
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])
}

enum Gender {
  MALE
  FEMALE
  BINARY
}

enum Role {
  PATIENT
  DOCTOR
  ADMIN
}

enum Specialty {
  CARDIOLOGIST
  DERMATOLOGIST
  PEDIATRICIAN
  NEUROLOGIST
  NEPHROLOGIST
  GASTROENTEROLOGIST
  ENDOCRINOLOGIST
  PULMONOLOGIST
  ONCOLOGIST
  ORTHOPEDIC
  OPHTHALMOLOGIST
  OTOLARYNGOLOGIST
  UROLOGIST
  RHEUMATOLOGIST
  PSYCHIATRIST
  PSYCHOLOGIST
  GENERAL_PHYSICIAN
  GENERAL_SURGEON
  RADIOLOGIST
  PATHOLOGIST
  HEMATOLOGIST
  DENTIST
  GYNECOLOGIST
  OBSTETRICIAN
  PLASTIC_SURGEON
  VASCULAR_SURGEON
  CARDIOTHORACIC_SURGEON
  DERMATOSURGEON
  INFECTIOUS_DISEASE_SPECIALIST
  IMMUNOLOGIST
  ANESTHESIOLOGIST
  EMERGENCY_MEDICINE
  SPORTS_MEDICINE
  PAIN_MEDICINE
  CRITICAL_CARE
  PHYSIOTHERAPIST
  NUTRITIONIST
}

enum Qualification {
  MBBS
  BDS
  BPT
  BHMS
  BAMS
  MD
  MS
  DNB
  MDS
  DM
  MCH
  MPH
  MBA_HM
  PHD
  DO
  FELLOWSHIP
  PGD
}

enum SlotStatus {
  AVAILABLE
  HELD
  BOOKED
  UNAVAILABLE
  CANCELLED
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
  NO_SHOW
  RESCHEDULED
}

// ======================================================
// USER, ADMIN, DOCTOR, PATIENT MODELS
// ======================================================

model User {
  id       String @id @default(cuid())
  email    String @unique
  phoneNo  String
  name     String
  password String
  age      Int

  gender Gender @default(MALE)
  role   Role   @default(PATIENT)

  address String
  city    String
  state   String
  pinCode Int

  admin   Admin?
  doctor  Doctor?
  patient Patient?

  accessLogs AccessLog[]
  auditLogs  AuditLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Admin {
  id     String @id @default(cuid())
  userId String @unique

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Doctor {
  id             String          @id @default(cuid())
  userId         String          @unique
  specialty      Specialty
  experience     Int             @default(0)
  qualifications Qualification[]
  fees           Int             @default(0) // store in smallest currency unit (e.g., cents) or use Decimal

  user             User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  leaves           Leave[]
  schedule         Schedule?
  patientRelations DoctorPatientRelation[]
  appointments     Appointment[] // back-relation
  slots            Slot[] // convenience back-relation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Patient {
  id     String @id @default(cuid())
  userId String @unique

  medicalHistory     String @default("")
  allergies          String @default("")
  currentMedications String @default("")

  user            User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  doctorRelations DoctorPatientRelation[]
  appointments    Appointment[] // back-relation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ======================================================
// DOCTOR MODULE (Leave, Schedule, Availability, Slot, Appointment)
// ======================================================

model Leave {
  id       String @id @default(cuid())
  doctorId String

  doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  reason    String
  startDate DateTime
  endDate   DateTime
  applyAt   DateTime @default(now())

  @@unique([doctorId, startDate, endDate])
  @@index([doctorId])
  @@index([startDate, endDate])
}

/**
 * Weekly schedule JSON is the canonical repeating schedule (e.g. working hours per weekday).
 * Use this for generating Slots for upcoming days.
 * Example format:
 * {
 * "monday": [{ "start": "09:00", "end": "13:00" }, { "start": "15:00", "end": "18:00" }],
 * ...
 * }
 */
model Schedule {
  id             String @id @default(cuid())
  doctorId       String @unique
  weeklySchedule Json

  doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}



/**
 * Slot = a discrete time window for a doctor (bookable)
 * - startTime/endTime are full timestamps in UTC
 * - status: AVAILABLE / HELD / BOOKED / etc
 * Slot is the defining side of the one-to-one relation to Appointment:
 * - appointmentId is the scalar FK (unique)
 * - appointment relation uses @relation(fields: [appointmentId], references: [id], onDelete: SetNull)
 * Appointment will not declare scalar fields for this relation (Prisma infers inverse).
 */
model Slot {
  id              String       @id @default(cuid())
  doctorId        String
  date            DateTime     @db.Date // slot date
  startTime       DateTime
  endTime         DateTime
  status          SlotStatus   @default(AVAILABLE)
  heldByPatientId String? // temporary hold
  heldAt          DateTime?
  // link to appointment if booked (one-to-one) — this is the defining side
  appointmentId   String?      @unique
  appointment     Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)

  doctor    Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([doctorId, date, startTime])
  @@index([doctorId, date, status])
  @@index([startTime, status])
  @@index([heldByPatientId])
}

/**
 * Appointment = finalized booking of a patient with a doctor.
 * NOTE: removed the scalar field `slotId` (it was duplicating the relation).
 * The inverse relation `slot` is declared without @relation attributes; Prisma will infer it.
 */
model Appointment {
  id                  String            @id @default(cuid())
  // slotId removed — Slot.appointmentId is the defining scalar FK
  doctorId            String
  patientId           String
  status              AppointmentStatus @default(PENDING)
  notes               String?
  cancelReason        String?
  cancelledAt         DateTime?
  appointmentDateTime DateTime // canonical appointment time (start)
  durationMinutes     Int               @default(30) // you can adjust default
  bookedAt            DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  // inverse relation — no scalar / fields specified here
  slot    Slot?
  doctor  Doctor  @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // optional links to payment/prescription (removed per request)

  @@unique([doctorId, appointmentDateTime]) // prevents two appointments at same time for same doctor
  @@index([doctorId, patientId])
  @@index([status])
  @@index([appointmentDateTime])
}

// ======================================================
// DOCTOR–PATIENT RELATION MODEL
// ======================================================

model DoctorPatientRelation {
  id        String @id @default(cuid())
  doctorId  String
  patientId String

  doctor  Doctor  @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([doctorId, patientId])
  @@index([patientId])
  @@index([doctorId])
}

// ======================================================
// LOG MODELS
// ======================================================

model AccessLog {
  id       String  @id @default(cuid())
  userId   String?
  targetId String?
  action   String

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
}

model AuditLog {
  id       String  @id @default(cuid())
  userId   String?
  action   String
  metadata Json?

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
}
