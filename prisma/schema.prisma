// ======================================================
// ROOT PRISMA SETUP (Prisma 7 compatible)
// ======================================================

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  // url = env("DATABASE_URL")
}

// ======================================================
// ENUMS
// ======================================================

enum Gender {
  MALE
  FEMALE
  BINARY
}

enum Role {
  PATIENT
  DOCTOR
  ADMIN
}

enum Specialty {
  CARDIOLOGIST
  DERMATOLOGIST
  PEDIATRICIAN
  NEUROLOGIST
  NEPHROLOGIST
  GASTROENTEROLOGIST
  ENDOCRINOLOGIST
  PULMONOLOGIST
  ONCOLOGIST
  ORTHOPEDIC
  OPHTHALMOLOGIST
  OTOLARYNGOLOGIST
  UROLOGIST
  RHEUMATOLOGIST
  PSYCHIATRIST
  PSYCHOLOGIST
  GENERAL_PHYSICIAN
  GENERAL_SURGEON
  RADIOLOGIST
  PATHOLOGIST
  HEMATOLOGIST
  DENTIST
  GYNECOLOGIST
  OBSTETRICIAN
  PLASTIC_SURGEON
  VASCULAR_SURGEON
  CARDIOTHORACIC_SURGEON
  DERMATOSURGEON
  INFECTIOUS_DISEASE_SPECIALIST
  IMMUNOLOGIST
  ANESTHESIOLOGIST
  EMERGENCY_MEDICINE
  SPORTS_MEDICINE
  PAIN_MEDICINE
  CRITICAL_CARE
  PHYSIOTHERAPIST
  NUTRITIONIST
}

enum Qualification {
  MBBS
  BDS
  BPT
  BHMS
  BAMS
  MD
  MS
  DNB
  MDS
  DM
  MCH
  MPH
  MBA_HM
  PHD
  DO
  FELLOWSHIP
  PGD
}

enum SlotStatus {
  AVAILABLE
  HELD
  BOOKED
  UNAVAILABLE
  CANCELLED
}

enum AppointmentStatus {
  PENDING       // created, not yet confirmed by doctor/patient
  CONFIRMED     // both sides confirmed
  COMPLETED
  CANCELLED
  NO_SHOW
  RESCHEDULED
}

// ======================================================
// USER, ADMIN, DOCTOR, PATIENT MODELS
// ======================================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  phoneNo   String
  name      String
  password  String
  age       Int

  gender    Gender   @default(MALE)
  role      Role     @default(PATIENT)

  address   String
  city      String
  state     String
  pinCode   Int

  admin     Admin?
  doctor    Doctor?
  patient   Patient?

  accessLogs AccessLog[]
  auditLogs  AuditLog[]
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Admin {
  id        String   @id @default(cuid())
  userId    String   @unique

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Doctor {
  id               String                @id @default(cuid())
  userId           String                @unique
  specialty        Specialty
  experience       Int                   @default(0)
  qualifications   Qualification[]
  fees             Int                   @default(0) // store in smallest currency unit (e.g., cents) or use Decimal

  user             User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  leaves           Leave[]
  schedule         Schedule?
  patientRelations DoctorPatientRelation[]
  appointments     Appointment[]         // back-relation
  availabilities   DoctorAvailability[]  // availability by date
  slots            Slot[]                // convenience back-relation

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model Patient {
  id                 String   @id @default(cuid())
  userId             String   @unique

  medicalHistory     String   @default("")
  allergies          String   @default("")
  currentMedications String   @default("")

  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  doctorRelations    DoctorPatientRelation[]
  appointments       Appointment[]  // back-relation

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

// ======================================================
// DOCTOR MODULE (Leave, Schedule, Availability, Slot, Appointment)
// ======================================================

model Leave {
  id        String   @id @default(cuid())
  doctorId  String

  doctor    Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  reason    String
  startDate DateTime
  endDate   DateTime
  applyAt   DateTime @default(now())

  @@unique([doctorId, startDate, endDate])
  @@index([doctorId])
  @@index([startDate, endDate])
}

/**
 * Weekly schedule JSON is the canonical repeating schedule (e.g. working hours per weekday).
 * Use this for generating DoctorAvailability & Slots for upcoming days.
 * Example format:
 * {
 *   "monday": [{ "start": "09:00", "end": "13:00" }, { "start": "15:00", "end": "18:00" }],
 *   ...
 * }
 */
model Schedule {
  id             String   @id @default(cuid())
  doctorId       String   @unique
  weeklySchedule Json

  doctor         Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

/**
 * DoctorAvailability = availability record for a specific date (date only).
 * Holds meta information and a list of slots for that day.
 */
model DoctorAvailability {
  id              String    @id @default(cuid())
  doctorId        String
  // store date-only; use @db.Date for postgres date type
  date            DateTime  @db.Date
  isAvailable     Boolean   @default(true)
  notes           String?

  doctor          Doctor    @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  slots           Slot[]

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([doctorId, date])
  @@index([doctorId, date])
  @@index([date, isAvailable])
}

/**
 * Slot = a discrete time window on a given DoctorAvailability (bookable)
 * - startTime/endTime are full timestamps in UTC
 * - status: AVAILABLE / HELD / BOOKED / etc
 */
model Slot {
  id                    String              @id @default(cuid())
  doctorAvailabilityId  String
  startTime             DateTime
  endTime               DateTime
  status                SlotStatus          @default(AVAILABLE)
  heldByPatientId       String?             // temporary hold
  heldAt                DateTime?
  // link to appointment if booked (one-to-one)
  appointmentId         String?             @unique
  appointment           Appointment?        @relation(fields: [appointmentId], references: [id], onDelete: SetNull)

  doctorAvailability    DoctorAvailability  @relation(fields: [doctorAvailabilityId], references: [id], onDelete: Cascade)
  // convenience relation to doctor through availability
  // createdAt/updatedAt for auditing
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt

  @@unique([doctorAvailabilityId, startTime])
  @@index([doctorAvailabilityId, status])
  @@index([startTime, status])
  @@index([heldByPatientId])
}

/**
 * Appointment = finalized booking of a patient with a doctor.
 * - slotId is optional if you allow free-form datetime bookings (but in the Slot approach usually slotId is present)
 * - appointmentDateTime duplicated for quick queries/search (should match slot startTime if slot used)
 */
model Appointment {
  id                  String            @id @default(cuid())
  slotId              String?           // optional (if booked against a Slot)
  doctorId            String
  patientId           String
  status              AppointmentStatus @default(PENDING)
  notes               String?
  cancelReason        String?
  cancelledAt         DateTime?
  appointmentDateTime DateTime          // canonical appointment time (start)
  durationMinutes     Int               @default(30) // you can adjust default
  bookedAt            DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  slot                Slot?             @relation(fields: [slotId], references: [id], onDelete: SetNull)
  doctor              Doctor            @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient             Patient           @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // optional links to payment/prescription
  payment             Payment?
  prescription        Prescription?

  @@unique([doctorId, appointmentDateTime]) // prevents two appointments at same time for same doctor
  @@index([doctorId, patientId])
  @@index([status])
  @@index([appointmentDateTime])
}

// ======================================================
// DOCTORâ€“PATIENT RELATION MODEL
// ======================================================

model DoctorPatientRelation {
  id        String   @id @default(cuid())
  doctorId  String
  patientId String

  doctor    Doctor  @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([doctorId, patientId])
  @@index([patientId])
  @@index([doctorId])
}

// ======================================================
// LOG MODELS
// ======================================================

model AccessLog {
  id        String   @id @default(cuid())
  userId    String?
  targetId  String?
  action    String

  user      User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    String
  metadata  Json?

  user      User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
}
